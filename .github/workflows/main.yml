      - name: Detect & print repo layout (for debugging)
        shell: bash
        run: |
          echo "=== tree (top-level) ==="
          ls -la
          echo "=== tree server-like dirs (depth 2) ==="
          for d in server serveur src api dist build; do
            [ -d "$d" ] && { echo "--- $d ---"; find "$d" -maxdepth 2 -type f | sed 's/^/  /'; }
          done

      - name: Detect API entrypoint (TS/JS) or compose
        id: detect
        shell: bash
        run: |
          set -e
          ts_candidates=( "server/index.ts" "server/app.ts" "server/main.ts" "serveur/index.ts" "serveur/app.ts" "serveur/main.ts" "src/server/index.ts" "src/server.ts" "src/app.ts" "src/main.ts" "api/index.ts" "api/app.ts" "api/main.ts" )
          js_candidates=( "dist/server/index.js" "dist/server.js" "dist/app.js" "dist/main.js" "build/server/index.js" "build/server.js" "build/app.js" "build/main.js" "server/index.js" "server/app.js" "server/main.js" "api/index.js" "api/app.js" "api/main.js" )
          found_ts=""; found_js=""; found_compose=""
          for f in "${ts_candidates[@]}"; do [ -f "$f" ] && { found_ts="$f"; break; }; done
          if [ -z "$found_ts" ]; then
            for f in "${js_candidates[@]}"; do [ -f "$f" ] && { found_js="$f"; break; }; done
          fi
          for f in docker-compose.yml docker-compose.yaml compose.yml compose.yaml .docker/compose.yml .docker/compose.yaml; do
            [ -f "$f" ] && { found_compose="$f"; break; }
          done
          echo "ts_entry=$found_ts" >> "$GITHUB_OUTPUT"
          echo "js_entry=$found_js" >> "$GITHUB_OUTPUT"
          echo "compose_file=$found_compose" >> "$GITHUB_OUTPUT"
          echo "Detected: ts='$found_ts' js='$found_js' compose='$found_compose'"

      - name: Start API (background) with multiple strategies
        shell: bash
        run: |
          set -e
          export PORT=3001
          export API_PORT=3001
          export VITE_API_PORT=3001
          TS_ENTRY="${{ steps.detect.outputs.ts_entry }}"
          JS_ENTRY="${{ steps.detect.outputs.js_entry }}"
          COMPOSE_FILE="${{ steps.detect.outputs.compose_file }}"
          if [ -n "$COMPOSE_FILE" ]; then
            echo "Starting via docker compose: $COMPOSE_FILE"
            docker compose -f "$COMPOSE_FILE" up -d || docker-compose -f "$COMPOSE_FILE" up -d
            echo "compose" > api.mode
          elif [ -n "$TS_ENTRY" ]; then
            echo "Starting TS entry: $TS_ENTRY"
            PORT=$PORT API_PORT=$API_PORT VITE_API_PORT=$VITE_API_PORT npx tsx "$TS_ENTRY" > api.log 2>&1 & echo $! > api.pid
            echo "tsx" > api.mode
          elif [ -n "$JS_ENTRY" ]; then
            echo "Starting JS entry: $JS_ENTRY"
            PORT=$PORT API_PORT=$API_PORT VITE_API_PORT=$VITE_API_PORT node "$JS_ENTRY" > api.log 2>&1 & echo $! > api.pid
            echo "node" > api.mode
          elif npm run | grep -q '^  dev:server'; then
            echo "Starting npm run dev:server"
            PORT=$PORT API_PORT=$API_PORT VITE_API_PORT=$VITE_API_PORT npm run dev:server > api.log 2>&1 & echo $! > api.pid
            echo "npm" > api.mode
          elif npm run | grep -q '^  dev:api'; then
            echo "Starting npm run dev:api"
            PORT=$PORT API_PORT=$API_PORT VITE_API_PORT=$VITE_API_PORT npm run dev:api > api.log 2>&1 & echo $! > api.pid
            echo "npm" > api.mode
          else
            echo "Starting fallback: npm run dev"
            PORT=$PORT API_PORT=$API_PORT VITE_API_PORT=$VITE_API_PORT npm run dev > api.log 2>&1 & echo $! > api.pid
            echo "npm" > api.mode
          fi
          sleep 2
          MODE="$(cat api.mode || true)"
          if [ "$MODE" != "compose" ] && [ -f api.pid ]; then
            if ! ps -p $(cat api.pid) >/dev/null 2>&1; then
              echo "::error::API process exited immediately"
              echo "-------- api.log (full) --------"
              cat api.log || true
              exit 1
            fi
          fi
          echo "API start strategy = $MODE"

      - name: Wait for health on multiple ports & paths (prints logs regularly)
        shell: bash
        run: |
          set +e
          ports=(3001 3000 5173 8080 5000)
          paths=("/api/health" "/health" "/healthz" "/status" "/api/v1/health")
          ok=false
          echo "Probing ports: ${ports[*]}"
          echo "Probing paths: ${paths[*]}"
          for i in {1..150}; do
            for p in "${ports[@]}"; do
              for path in "${paths[@]}"; do
                if curl -fsS "http://localhost:${p}${path}" >/dev/null; then
                  echo "API is up at http://localhost:${p}${path}"
                  echo "HEALTH_URL=http://localhost:${p}${path}" >> "$GITHUB_ENV"
                  ok=true
                  break 3
                fi
              done
            done
            if [ $((i % 10)) -eq 0 ]; then
              echo "---- api.log (last 120 lines, t=$((i*2))s) ----"
              if [ -f api.log ]; then tail -n 120 api.log || true; fi
            fi
            sleep 2
          done
          if [ "$ok" != true ]; then
            echo "::warning::API did not become healthy in time, continuingâ€¦"
          fi
          exit 0
